# encoding: utf-8
require 'rss'
require 'nokogiri'
require 'open-uri'

class RootFSCVEFeed
  attr_reader :stack
  attr_reader :stacks_dir

  SUPPORTED_STACKS = ['cflinuxfs3', 'cflinuxfs4', 'cflinuxfs5'].freeze

  def initialize(stack, stacks_dir)
    @stack = stack
    @stacks_dir = stacks_dir
  end

  def related_cves(system_name)
    raise "#{@stack} receipt not found in '#{@stacks_dir}'" unless receipt_found
    return [] unless rss

    @related_cves ||= rss.items.select do |item|
      usn_body = safe_uri_open(item.link).read
      html = Nokogiri::HTML(
        usn_body,
        nil,
        nil,
        Nokogiri::XML::ParseOptions::NOBLANKS | Nokogiri::XML::ParseOptions::RECOVER
      )
      os_version_header = html.css('h5').find { |h5| h5.text.include?(system_name) }

      next unless os_version_header
      package_list = os_version_header.css('+ ul')

      packages = package_list.css('li').map do |li|
        li.css('a:first').text
      end.reject(&:empty?)

      packages.any? do |name, _version|
        find_vulnerability_in_receipt(name)
      end
    end.map(&:title)
  end

  def unrelated_cves(system_name)
    all_cves(system_name) - related_cves(system_name)
  end

  private

  def all_cves(system_name)
    raise "#{@stack} receipt not found in '#{@stacks_dir}'" unless receipt_found
    rss.items.map(&:title)
  end

  def feed_uri
    'https://ubuntu.com/security/notices/rss.xml'
  end

  def rss
    @rss ||= RSS::Parser.parse(safe_uri_open(feed_uri), false)
  end

  def receipt_found
    if SUPPORTED_STACKS.include?(@stack)
      File.exist? "#{@stacks_dir}/receipt.#{@stack}.x86_64"
    else
      raise "Unsupported stack #{@stack}"
    end
  end

  def find_vulnerability_in_receipt(name)
    regex = "\\s#{name}(:amd64)*\\s"
    Dir.chdir(@stacks_dir) do
      if name != ""
        if SUPPORTED_STACKS.include?(@stack)
          !open("receipt.#{@stack}.x86_64", 'r').grep(/#{regex}/).empty?
        else
          raise "Unsupported stack #{@stack}"
        end
      end
    end
  end

  def safe_uri_open(url, max_attempts: 5, base_sleep: 2)
    attempts = 0
    begin
      attempts += 1
      URI.open(url)
    rescue => e
      if attempts < max_attempts
        sleep_time = base_sleep * (2 ** (attempts - 1))
        warn "Failed to open #{url} (#{e.class}: #{e.message}), retrying in #{sleep_time}s (attempt #{attempts}/#{max_attempts})"
        sleep sleep_time
        retry
      else
        warn "Failed to open #{url} after #{max_attempts} attempts: #{e.class}: #{e.message}"
        raise
      end
    end
  end
end
